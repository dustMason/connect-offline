// Generated by CoffeeScript 1.3.3
(function() {
  var ConnectOffline, fs, offline, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  fs = require('fs');

  module.exports = offline = function(options) {
    var connectOffline, _ref, _ref1, _ref2, _ref3;
    if (options == null) {
      options = {};
    }
    if ((_ref = options.networks) == null) {
      options.networks = [];
    }
    if ((_ref1 = options.fallbacks) == null) {
      options.fallbacks = null;
    }
    if ((_ref2 = options.files) == null) {
      options.files = [];
    }
    if ((_ref3 = options.manifest_path) == null) {
      options.manifest_path = '/application.manifest';
    }
    connectOffline = module.exports.instance = new ConnectOffline(options);
    return connectOffline.middleware;
  };

  ConnectOffline = (function() {

    function ConnectOffline(options) {
      this.options = options;
      this.middleware = __bind(this.middleware, this);

      this.latestmtime = 0;
    }

    ConnectOffline.prototype.header_section = function() {
      return "CACHE MANIFEST\n" + "# " + this.latestmtime.toUTCString();
    };

    ConnectOffline.prototype.cache_section = function() {
      var dir, dir_path, filename, files, root, stat, _i, _j, _len, _len1, _ref, _ref1;
      files = [];
      root = process.cwd();
      _ref = this.options.files;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dir = _ref[_i];
        dir_path = root + dir.dir;
        _ref1 = fs.readdirSync(dir_path);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          filename = _ref1[_j];
          files.push(dir.prefix + filename);
          stat = fs.statSync(dir_path + '/' + filename);
          if (stat.mtime > this.latestmtime) {
            this.latestmtime = stat.mtime;
          }
        }
      }
      return "\nCACHE:\n" + files.join("\n");
    };

    ConnectOffline.prototype.networks_section = function() {
      if (this.options.networks.length) {
        return "\nNETWORK:\n" + this.options.networks.join("\n");
      }
    };

    ConnectOffline.prototype.fallbacks_section = function() {
      if (this.options.fallbacks !== null) {
        return "\nFALLBACK:\n" + _.map(this.options.fallbacks, function(second, first) {
          return first + " " + second;
        }).join("\n");
      }
    };

    ConnectOffline.prototype.response = function() {
      return [this.header_section(), this.cache_section(), this.networks_section(), this.fallbacks_section()].join("\n");
    };

    ConnectOffline.prototype.middleware = function(req, res, next) {
      var manifest;
      if (this.options.manifest_path === req.url) {
        if (this.latestmtime === 0) {
          this.latestmtime = new Date();
        }
        manifest = this.response();
        res.writeHead(200, {
          "Content-Type": "text/cache-manifest",
          "Last-Modified": this.latestmtime.toUTCString(),
          "Content-Length": manifest.length
        });
        return res.end(manifest);
      } else {
        return next();
      }
    };

    return ConnectOffline;

  })();

}).call(this);
