// Generated by CoffeeScript 1.3.3
(function() {
  var ConnectOffline, fs, offline, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  fs = require('fs');

  module.exports = offline = function(options) {
    var connectOffline, _ref, _ref1, _ref2, _ref3, _ref4;
    if (options == null) {
      options = {};
    }
    if ((_ref = options.networks) == null) {
      options.networks = [];
    }
    if ((_ref1 = options.fallbacks) == null) {
      options.fallbacks = null;
    }
    if ((_ref2 = options.files) == null) {
      options.files = [];
    }
    if ((_ref3 = options.manifest_path) == null) {
      options.manifest_path = '/application.manifest';
    }
    if ((_ref4 = options.use_fs_watch) == null) {
      options.use_fs_watch = false;
    }
    connectOffline = module.exports.instance = new ConnectOffline(options);
    return connectOffline.middleware;
  };

  ConnectOffline = (function() {

    function ConnectOffline(options) {
      var _this = this;
      this.options = options;
      this.middleware = __bind(this.middleware, this);

      this.load_file_list();
      this.update_latestmtime();
      if (this.options.use_fs_watch) {
        this.watchers = [];
        this.watch_files(function(event, filename) {
          if (event === 'change') {
            return _this.latestmtime = new Date();
          }
        });
      }
    }

    ConnectOffline.prototype.load_file_list = function() {
      var root;
      root = process.cwd();
      this.options.files = _.map(this.options.files, function(set) {
        set.filenames = fs.readdirSync(root + set.dir);
        set.full_paths = _.map(set.filenames, function(filename) {
          return root + set.dir + '/' + filename;
        });
        return set;
      });
      return this.all_files = _.flatten(_.pluck(this.options.files, 'full_paths'));
    };

    ConnectOffline.prototype.update_latestmtime = function() {
      var file, stat, _i, _len, _ref, _results;
      this.latestmtime || (this.latestmtime = 0);
      _ref = this.all_files;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        stat = fs.statSync(file);
        if (stat.mtime > this.latestmtime) {
          _results.push(this.latestmtime = stat.mtime);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ConnectOffline.prototype.watch_files = function(callback) {
      var file, _i, _len, _ref, _results;
      _ref = this.all_files;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        _results.push(this.watchers.push(fs.watch(file, {
          persistent: true
        }, callback)));
      }
      return _results;
    };

    ConnectOffline.prototype.header_section = function() {
      if (!this.options.use_fs_watch) {
        this.update_latestmtime();
      }
      return "CACHE MANIFEST\n" + "# " + this.latestmtime.getTime();
    };

    ConnectOffline.prototype.cache_section = function() {
      var dir, filename, relative_paths, _i, _j, _len, _len1, _ref, _ref1;
      relative_paths = [];
      _ref = this.options.files;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dir = _ref[_i];
        _ref1 = dir.filenames;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          filename = _ref1[_j];
          relative_paths.push(dir.prefix + filename);
        }
      }
      return "\nCACHE:\n" + relative_paths.join("\n");
    };

    ConnectOffline.prototype.networks_section = function() {
      if (this.options.networks.length) {
        return "\nNETWORK:\n" + this.options.networks.join("\n");
      }
    };

    ConnectOffline.prototype.fallbacks_section = function() {
      if (this.options.fallbacks !== null) {
        return "\nFALLBACK:\n" + _.map(this.options.fallbacks, function(second, first) {
          return first + " " + second;
        }).join("\n");
      }
    };

    ConnectOffline.prototype.response = function() {
      return [this.header_section(), this.cache_section(), this.networks_section(), this.fallbacks_section()].join("\n");
    };

    ConnectOffline.prototype.middleware = function(req, res, next) {
      var manifest;
      if (this.options.manifest_path === req.url) {
        if (this.latestmtime === 0) {
          this.latestmtime = new Date();
        }
        manifest = this.response();
        res.writeHead(200, {
          "Content-Type": "text/cache-manifest",
          "Last-Modified": this.latestmtime.getTime(),
          "Content-Length": manifest.length
        });
        return res.end(manifest);
      } else {
        return next();
      }
    };

    return ConnectOffline;

  })();

}).call(this);
